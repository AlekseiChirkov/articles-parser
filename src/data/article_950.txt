Название: Kotlin Null-Safety vs ClassLoader

Автор: LonelyDeveloper97

Дата: 2021-09-15, 11:52

Теги: Ненормальное программирование *, Java *, Компиляторы *, Отладка *,
Kotlin *

Контент: Недавно я проходил собеседование и одним из вопросов, стал такой
загадочный экземпляр: "А какое главное преимущество системы типов
Kotlin перед Java"? Честно говоря, выделить какое преимущество
считалось главным, оказалось неразрешимой для меня задачей: Nothing,
отсутсвие Wildcard и First-Class Functions вместо Java-костыля с
Functional Interface (имеется ввиду 8я версия Java) не заняли первых
мест в личном топе интервьюера, который мне предложили угадать.
Оказалось что главное в Kotlin - возможность обьявить Nullable Type и
Null Safety подход (Замечу, что по моему опыту собственные или
библиотечные Optional или Maybe решают эту проблему, и пишутся за 10
минут на Java 7. А еще есть аннотации Nullable, позволяющие проверять
поля в сompile-time. Короче, есть много способов заставить делать Null
проверки в plain Java. Ну да ладно). Но речь пойдет не о странных
вопросах, связанных со вкусовыми предпочтениями интервьюеров
относительно синтаксического сахара. Дело в том, что Null Safety в
Kotlin можно сломать, притом не выходя из под его безопасного купола в
суровый дикий мир Java и Null-Referrences.Как? Long story short:
ClassLoader ведет себя интересным образом при попытке загрузить
статические поля классов рекурсивно ссылающиеся на классы друг-друга.
Под катом примеры кода и подробное объяснение того, как он обманывает
проверки на Nullable. Я искренне надеюсь что специфические знания
Java/Kotlin для статьи не нужны - я объясню все детали на ходу, и
уложу расследование в 10 минут.